const int WIDTH
const int HIGH

char* char_buffer
int* pos_buffer
int buf_size
char* query_key
int key_len
int idx
int find_flag
int show_flag

int main()
{
	char c;
	while(1)
	{
		c = keyboard_read();
		if(find_flag&& show_flag && c!=ESC)
			continue;
		if(find_flag)
		{
			case ESC:
				reset_idx();
				sti();
				find_flag=false;
				break;
			case \b:
				backspace();
                append(query_key, c, key_len);
				key_len++;
                break;
            case \n:
				find_word(key);
				show_flag=true;
				break;
			case char:
				append(key, c, key_len);
				key++;
				print_color(c, BLUE);
				break;

			default:
				break;
		}
		else
		{
			switch(c)
			{
				case ESC:
					cli();
					find_flag=true;
					break;
                 case \b:
                    append(char_buffer, c, buf_size);
					buf_size++;
                    backspace();
                    break;
				case \n:
					append(char_buffer, c, buf_size);
					buf_size++;
					return_idx();
					break;
				case \t:
					append(char_buffer, c, buf_size);
					buf_size++;
					print 4 spaces
					break;
				case cancel:

					if(p_tty->cache_size>0)
					{
						if(p_tty->char_cache[p_tty->cache_size-1]!='\b)
							backward_clean(p_tty->p_console, 1);
						else
						{
							u32 c = find_last_char(p_tty);
							out_char(p_tty->p_console, c);
						}
						p_tty->cache_size--;
					}
					break;
				case char:
					append(char_buffer, c, buf_size);
					buf_size++;
					print_color(c, WHITE);
					break;
				default:
					break;
			}
		}
		
	}
}

append(p, c, size)
{
    p[size]  = c;
}


void print_color(char c, int color)
{
    ...
}
void return_idx()
{
    //calculate idx by return key.
}

void replace(char c, int color)
{
    //replace the byte pointed by idx by c in specified color.
}

void backspace()
{
    replace(space, WHITE);
    int s = forward_steps
}

cli()
{
    //close interrupt
}

sti()
{
    //start interrupt
}

void clear()
{
    //clear screen on time interrupt occurring
}

int backward_steps()
{
    //calc how many steps idx had taken before printed current char 
}

int forward_steps()
{
    //calc how many steps idx had taken before printed current char
}

void query_and_highlight(TTY* p_tty)
{
	u32* st_array[MAX_CACHE_SIZE];
	u32* ed_array[MAX_CACHE_SIZE];
	match(p_tty->char_cache, 0, p_tty->cache_size, p_tty->query_key, p_tty->key_len, st_array, ed_array);
	unsigned i = 0;
	while(st_array[i]!=-1)
	{
		set_color(p_tty->p_console, st_array[i], ed_array[i], BLUE);
		i++;
	}

	//considering reset
}


PRIVATE u32 find_last_char(TTY* p_tty)
{
	u32* last_char = former_char(p_tty->char_cache +p_tty->cache_size, p_tty->char_cache);
	return last_char==nullptr? 0: *last_char;
		
	//unsigned int cur = p_tty->cache_size-1;
	//int posi_count = p_tty->char_cahe[cur--] == '\b'? -1:1;
	//while(posi_count<0 && cur>=0)
	//{
		//u32 c = p_tty->char_cahe[cur--];
		//posi_count+=(c=='\b'?-1:1);
	//}
	//return (posi_count<0? 0 : c);
}

PRIVATE void match(u32* str, unsigned int st, unsigned int ed, u32* key, unsigned int key_len, u32* st_array, u32* ed_array)
{
	memset(st_array, -1, MAX_CACHE_SIZE);
	memset(ed_array, -1, MAX_CACHE_SIZE);

	u32* cur_idx = former_char(str+ed, str);
	int res_len = 0;

	while(cur_idx!=nullptr)
	{
		int i=key_len-1
		u32* ed_idx = cur_idx;
		while(i>=0 && && cur_idx!=nullptr)
		{
			if(*cur_idx!=key[i] )
				break;
			i--;
			cur_idx = former_char(cur_idx, str);
		}
		if(i<0)
		{
			cur_idx = former_char(cur_idx, str);
			st_array[res_len] = cur_idx==nullptr? 0:(cur_idx - str);
			ed_array[res_len] = ed_idx - str;
			res_len++;
		}
	}
}

PRIVATE u32* former_char(u32* st, u32* head)
{
	u32* p = st - 1;
	int valid_ct = 0;
	while(p>=head && valid_ct<=0)
	{
		valid_ct+=(*p=='\b'?-1:1);
		p--;
	}
	return valid_ct>0?p:nullptr;
}

PUBLIC void set_color(CONSOLE* p_con, unsigned int st_cursor, unsigned int ed_cursor, char color)
{
	unsigned int ct = 0;
	u8* vmem = (u8*)(V_MEM_BASE + st_cursor * 2);

	while(ct + st_cursor < ed_cursor)
	{
		*(vmem-1) = color;
		vmem+=2;
	}

	flush(p_con);
}
PUBLIC void out_char(CONSOLE* p_con, char ch)
{
	out_char(p_con, ch, DEFAULT_CHAR_COLOR);
}


PUBLIC void out_char(CONSOLE* p_con, char ch, char color)
{
	u8* p_vmem = (u8*)(V_MEM_BASE + p_con->cursor * 2);

	switch(ch) {
	case '\n':
		if (p_con->cursor < p_con->original_addr +
		    p_con->v_mem_limit - SCREEN_WIDTH) {
			p_con->cursor = p_con->original_addr + SCREEN_WIDTH * 
				((p_con->cursor - p_con->original_addr) /
				 SCREEN_WIDTH + 1);
		}
		break;
	case '\b':
		if (p_con->cursor > p_con->original_addr) {
			p_con->cursor--;
			*(p_vmem-2) = ' ';
			*(p_vmem-1) = color;
		}
		break;
	default:
		if (p_con->cursor <
		    p_con->original_addr + p_con->v_mem_limit - 1) {
			*p_vmem++ = ch;
			*p_vmem++ = color;
			p_con->cursor++;
		}
		break;
	}

	while (p_con->cursor >= p_con->current_start_addr + SCREEN_SIZE) {
		scroll_screen(p_con, SCR_DN);
	}

	flush(p_con);
}