# 问题解答

## 一、PPT相关内容

### 1.什么是实模式，什么是保护模式

1. 实模式就是用基地址加偏移量就可以直接拿到物理地址的模式。
实模式（英语：Real mode）是Intel 80286和之后的x86兼容CPU的操作模式。实模式的特性是一个20比特的区段存储器地址空间（意思为只有1MB的存储器可以被定址），可以直接软件访问BIOS例程以及周边硬件，没有任何硬件等级的存储器保护观念或多任务。所有的80286系列和之后的x86 CPU都是以实模式下引导；80186和早期的CPU仅仅只有一种操作模式，也就是相当于后来芯片的这种实模式。  
缺点：实模式非常不安全。

2. 保护模式就是不能直接拿到物理地址的模式。  
因此需要进行地址转换。从80386开始，是现代操作系统的主要模式。1985年问世的80386开启了32位CPU时代。地址总线为32比特，寻址空间为232（即4 GiB）。386 CPU保护模式下有两种内存寻址方式：  

- 可以分页寻址，这是此后的x86上的Windows操作系统与Linux操作系统最广泛采用的方法；
- 也可以非分页寻址而采取与286保护模式兼容的寻址方式，采用32位的选择器（selector）寄存器与32位的偏移量寄存器寻址，这时描述符表的条目中保存的段起始物理地址为32位，而段长的数据宽度为20位，但可以设置段长的粒度为1B或4KiB，所以段的最大长度可以是1 MiB或者4 GiB。

IA32的CPU通过两级：页目（page directory）与页表（page table）实现4KiB的分页管理，这是最常见的IA32分页寻址方式。  
从应用程序角度，不再使用段地址寄存器（或称选择器），仅使用32位的偏移量，为232（即4GiB）的连续线性寻址空间。  
参考: [维基百科: 实模式](https://zh.wikipedia.org/wiki/%E7%9C%9F%E5%AF%A6%E6%A8%A1%E5%BC%8F)、[维基百科: 保护模式](https://zh.wikipedia.org/wiki/%E4%BF%9D%E8%AD%B7%E6%A8%A1%E5%BC%8F)

### 2.什么是选择子

段选择子是一个16位的整数（段寄存器的16位可见部分），存储寻找段描述符的相关信息。其结构如下：  

```[text]
|   1   |     0    |  字节
|7654321076543 2 10|  比特
|-------------|-|--|  占位
|    INDEX    |T|R |  含义
|             |I|P |
|             | |L |
```

其中：

- INDEX：在GDT数组或LDT数组的索引号
- TI：Table Indicator,这个值为0表示查找GDT，1则查找LDT
- RPL：请求特权级。以什么样的权限去访问段。  

实际段选择子就是原先在16位时代中的段偏移量，32位时代后扩增了意义。

### 3.什么是描述符

保护模式下引入描述符来描述各种数据段，所有的描述符均为8个字节，由第5个字节来说明描述符的类型。类型不同，描述符的结构也不同。  
段描述符结构如下：

```[text]
|   7    |     6       |     5     |   4    |   3    |   2    |   1    |   0    |  字节
|76543210|7 6 5 4 3210 |7 65 4 3210|76543210|76543210|76543210|76543210|76543210|  比特
|--------|-|-|-|-|---- |-|--|-|----|--------|--------|--------|--------|--------|  占位
|  BASE  |G|D|0|A|LIMIT|P|D |S|TYPE|<------- BASE 23-0 ------>|<-- LIMIT 15-0 ->|  含义
|  31-24 | |/| |V|19-16| |P |
           |B| |L|     | |L |
```

其中：  

- BASE: 段基址，由上图中的两部分(BASE 31-24 和 BASE 23-0)组成
- G：LIMIT的单位，该位 0 表示单位是字节，1表示单位是 4KB
- D/B: 该位为 0 表示这是一个 16 位的段，1 表示这是一个 32 位段
- AVL: 该位是用户位，可以被用户自由使用
- LIMIT: 段的界限，单位由 G 位决定。数值上（经过单位换算后的值）等于段的长度（字节）- 1。
- P: 段存在位，该位为 0 表示该段不存在，为 1 表示存在。
- DPL：段权限
- S: 该位为 1 表示这是一个数据段或者代码段。为 0 表示这是一个系统段（比如调用门，中断门等）
- TYPE: 根据 S 位的结果，再次对段类型进行细分。  

### 4.什么是GDT，什么是LDT

1. GDT：全局描述符表，是全局唯一的。存放一些公用的描述符、和包含各进程局部描述符表首地址的描述符。
GDT用于提供段式存储机制，是由段寄存器和GDT中的描述符共同提供的。
2. LDT：局部描述符表，每个进程都可以有一个。存放本进程内使用的描述符。  
(以上可以理解为二级的表的结构，意为存放的都是各进程的段表的表，因为描述符记录着段表的基址)

### 5.请分别说明GDTR和LDTR的结构

1. GDTR(48位)寄存器中，高32位存放GDT表的首地址，低16位记录表的大小。  
2. LDTR(16位)寄存器中保存一个特殊的选择子，用于查找当前进程的LDT首地址。  

段寄存器低16位保存段选择子  
后16为attribute，对应的就是段描述符高4字节的8-23位。  
后32位为base，对应的有高4字节的24-31位和0-7位，还有低4字节的16-31位，这三部分构成了一个32位的地址。  
再后32位为limit，对应的有高4字节的16-19位，低4字节的0-15位，也就是说limit总共也就20位，转成16进制最大为0xFFFFF，剩下的12位是从哪里来呢？没错，就是段描述符的G位。如果G=0，在limit前面补000，最大可以表示0x**000**FFFFF；如果G=1，在limit后面补FFF，最大可以表示0xFFFFF**FFF**。  

### 6.请说明GDT直接查找物理地址的具体步骤

1. 给出段选择子+偏移量
段选择子记录着对GDT表的索引、类型(必为0)，和权限；偏移代表寻址偏移。
2. 选择了GDT方式(段选择子第三位为0)，从GDTR获取GDT首地址，用段选择子中的13位做偏移，拿到GDT中的描述符
描述符记录着为当前进程的段表基址，
3. 如果合法(不超过GDT表长度)且有权限(段选择子头2位代表权限)，用描述符中的段首地址加上1)中的偏移量找到物理地址。寻址结束。

### 7.请说明通过LDT查找物理地址的具体步骤

1. 给出段选择子+偏移量
段选择子记录着对LDT表的索引，查找类型(必为1)，和权限；偏移嗲表寻址偏移。
2. 若选择了LDT方式(段选择子第三位为1)，从GDTR获取GDT首地址，用LDTR中的偏移量做偏移，拿到GDT中的描述符1
LDTR记录着对GDT表的索引；描述符1记录着LDT表的基址。
3. 从描述符1中获取LDT首地址，用段选择子中的13位做偏移，拿到LDT中的描述符2
描述符2记录着当前进程的段表基址。
4. 如果合法且有权限，用描述符2中的段首地址加上1)中的偏移量找到物理地址。寻址结束。

### 8.根目录区大小一定么？扇区号是多少？为什么

根目录区最大有14个block(9728B)，扇区号从19开始，哪有为什么  

### 9.数据区第一个簇号是多少？为什么

在1.44M软盘上，FAT前三个字节的值是固定的0xF0、0xFF、0xFF，用于表示这是一个应用在1.44M软盘上的FAT12文件系统。本来序号为0和1的FAT表项应该对应于簇0和簇1，但是由于这两个表项被设置成了固定值，簇0和簇1就没有存在的意义了，所以数据区就起始于簇2。  

### 10.FAT表的作用

构成链表形式，作为数据区的索引。  

### 11.解释静态链接的过程

```[text]
gcc -c test.c
gcc -c my_lib.c
ar crv libmylib.a my_lib.o
ld(gcc) -o test test.o -L./ -lmylib
or gcc -o test test.o my_lib.o
```

- 特点：在生成可执行文件的时候(链接阶段)，把所有需要的函数的二进制代码都包含到可执行文件中去。因此，链接器需要知道参与链接的目标文件需要哪些函数，同时也要知道每个目标文件都能提供什么函数，这样链接器才能知道是不是每个目标文件所需要的函数都能正确地链接。如果某个目标文件需要的函数在参与链接的目标文件中找不到的话，链接器就报错了。目标文件中有两个重要的接口来提供这些信息：一个是符号表，另外一个是重定位表。
- 优点：在程序发布的时候就不需要的依赖库，也就是不再需要带着库一块发布，程序可以独立执行。

- 缺点：
  - 程序体积会相对大一些。
  - 如果静态库有更新的话，所有可执行文件都得重新链接才能用上新的静态库。

静态链接是指在编译阶段直接把静态库加入到可执行文件中去，这样可执行文件会比较大。
而动态链接则是指链接阶段仅仅只加入一些描述信息，而程序执行时再从系统中把相应动态库加载到内存中去。

### 12.解释动态链接的过程

```[text]
gcc -fPIC -c -g my_lib.c -o my_lib.o
gcc -shared my_lib.o -o lib.so
gcc -c -g dynamic_a.c -o da.o
gcc -c -g dynamic_b.c -o db.o
gcc -o da da.o -L./ -ld
gcc -o db db.o -L./ -ld

```

-shared 为使用动态链接　　
使用-fPIC产生位置无关的代码

- 特点： 在编译的时候不直接拷贝可执行代码，而是通过记录一系列符号和参数，在程序运行或加载时将这些信息传递给操作系统，操作系统负责将需要的动态库加载到内存中，然后程序在运行到指定的代码时，去共享执行内存中已经加载的动态库可执行代码，最终达到运行时连接的目的。
- 优点： 多个程序可以共享同一段代码，而不需要在磁盘上存储多个拷贝。
- 缺点： 由于是运行时加载，可能会影响程序的前期执行性能。

上面的文章多次提到库(lib)这个概念，所谓的库就是一些功能代码经过编译连接后的可执行形式。大家在Windows平台上见到的.dll文件和linux平台下so动态库都属于库。  
库也有静态lib和动态lib之分：  

- 静态lib将导出声明和实现都放在lib中。编译后所有代码都嵌入到宿主程序。
- 动态lib相当于一个h文件，是对实现部分（.dll文件）的导出部分的声明。编译后只是将导出声明部分编译到宿主程序中，运行时候需要相应的dll文件支持。

静态库（.a、.lib）和动态库（.so、.dll）  

### 13.静态链接相关PPT中为什么使用ld链接而不是gcc

gcc实际也调用了ld，但为ld提供了有关C的默认选项。

### 14.linux下可执行文件的虚拟地址空间默认从哪里开始分配

08048000

## 二、实验相关内容

### 1.BPB指定字段的含义

BIOS Parameter Block　　

```[c++]
    // 头３个字节：EB 3C 90　＝　JMP SHORT 3C NOP
    8 BS_OEMName[8];     //OEM字符串，必须为8个字符，不足以空格填空
    2 BPB_BytsPerSec;  //每扇区字节数, 默认为512
    1 BPB_SecPerClus;  //每簇占用的扇区数, 默认为1
    2 BPB_RsvdSecCnt;  //Boot占用的扇区数, 默认为1
    1 BPB_NumFATs;     //FAT表的记录数, 默认为2
    2 BPB_DirEntCnt;   //最大根目录文件数
    2 number BPB_TotSec16;    //逻辑扇区总数，如果值是0，说明磁盘中有超过2^16-1个扇区，并且真实值保存在 Large Sector 1 Count字段，在0x20处
    1 BPB_Media;         //媒体描述符
    2 BPB_FATSz16;     //每个FAT占用扇区数
    2 BPB_SecPerTrk;   //每个磁道扇区数
    2 BPB_NumHeads;    //磁头数
    4 BPB_HiddSec;     //隐藏扇区数
    4 BPB_TotSec32;    //如果BPB_TotSec16是0，则在这里记录
    1 BS_DrvNum;         //中断13的驱动器号
    1 BS_Reserved1;      //未使用
    1 BS_BootSig;        //扩展引导标志
    4 BS_VolID;        //卷序列号
    11 BS_VolLab[11];     //卷标，必须是11个字符，不足以空格填充
    8 BS_FileSysType[8]; //文件系统类型，必须是8个字符，不足填充空格

```

### 2.如何进入子目录并输出（说明方法调用）

从根目录开始查找，推栈，输出

### 3.如何获得指定文件的内容，即如何获得数据区的内容（比如使用指针等）

用fatlist(linked list)

### 4.如何进行C代码和汇编之间的参数传递和返回值传递

参数会按从右到左的顺序压入栈中，再压入返回地址，因此参数从`[esp+4]`开始　　
返回值存在eax中(32位中)。

### 5.汇编代码中对I/O的处理方式，说明指定寄存器所存值的含义

...
